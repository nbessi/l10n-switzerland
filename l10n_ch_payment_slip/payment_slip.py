# -*- coding: utf-8 -*-
##############################################################################
#
#    Author: Nicolas Bessi
#    Copyright 2014 Camptocamp SA
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as
#    published by the Free Software Foundation, either version 3 of the
#    License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
##############################################################################
import re

from openerp import models, fields, api, _
from openerp import exceptions
from openerp.tools.misc import mod10r


class PaymentSlip(models.Model):

    _compile_get_ref = re.compile('[^0-9]')

    _name = 'l10n_ch.payment_slip'

    reference = fields.Char('BVR/ESR Ref.',
                            compute='compute_ref')

    move_line_id = fields.Many2one('account.move.line',
                                   'Related move',
                                   ondelete='cascade')

    amout_total = fields.Float('Total amount of BVR/ESR',
                               compute='compute_amount',
                               store=True)

    scan_line = fields.Char('Scan Line',
                            compute='compute_scan_line',
                            store=True)
    scan_line_div = fields.Char('Scan Line Div',
                                compute='compute_scan_line_div',
                                store=True)

    @api.model
    def _can_generate(self, move_line):
        ''' Determine if BVR should be generated or not. '''
        # We check if the type is bvr, if not we return false
        invoice = move_line.invoice
        if not invoice:
            return False
        return (invoice.partner_bank_id and
                invoice.partner_bank_id.state == 'bvr')

    @api.one
    @api.model
    def _get_adherent_number(self):
        move_line = self.move_line_id
        ad_number = ''
        if move_line.invoice.partner_bank_id.bvr_adherent_num:
            ad_number = move_line.invoice.partner_bank_id.bvr_adherent_num
        return ad_number

    @api.one
    def _compute_amount_hook(self):
        """Hook to return the total amount of pyament slip

        :return: total amount of payment slip
        :rtype: float

        """
        return self.move_line_id.debit

    @api.one
    @api.depends('move_line_id',
                 'move_line_id.debit',
                 'move_line_id.credit')
    def compute_amount(self):
        """Return the total amount of pyament slip

        if you need to override please use
        :py:meth:`_compute_amount_hook`

        :return: total amount of payment slip
        :rtype: float

        """
        return self._compute_amount_hook()

    @api.one
    @api.depends('move_line_id')
    def compute_ref(self):
        """Retrieve ESR/BVR reference from move line in order to print it

        Returns False when no BVR reference should be generated.  No
        reference is generated when a transaction reference already
        exists for the line (likely been generated by a payment service).
        """
        if not self.can_generate(self.move_line_id):
            return ''
        move_line = self.move_line_id
        # We sould not use technical id but will keep it for historical reason
        move_number = str(move_line.id)
        ad_number = self._get_adherent_number()
        if move_line.invoice.number:
            compound = move_line.invoice.number + str(move_line.id)
            move_number = self._compile_get_ref.sub('', compound)
        reference = mod10r(
            ad_number + move_number.rjust(26 - len(ad_number), '0')
        )
        self.reference = reference
        return reference

    @api.model
    def _space(self, nbr, nbrspc=5):
        """Spaces ref by group of 5 digits.

        Example:
            AccountInvoice._space('123456789012345')
            '12 34567 89012 345'

        :param nbr: reference to group
        :type nbr: int

        :param nbrspc: group length
        :type nbrspc: int

        :return: grouped reference
        :rtype: str

        """
        return ''.join([' '[(i - 2) % nbrspc:] + c for i, c in enumerate(nbr)])

    @api.one
    @api.model
    def _compute_scan_line_list(self):
        line = []
        if not self.can_generate(self.move_line_id):
            return []
        amount = '01%.2f' % self.amount_total
        justified_amount = amount.replace('.', '').rjust(10, '0')
        line += [char for char in mod10r(justified_amount)]
        line.append('&gt;')
        line += [char for char in self.reference]
        line.append('+')
        line.append('&nbsp;')
        bank = self.move_line_id.invoice.partner_bank_id.get_account_number()
        account_components = bank.split('-')
        bank_identifier = "%s%s%s" % (
            account_components[0],
            account_components[1].rjust(6, '0'),
            account_components[2]
        )
        line += [car for car in bank_identifier]
        line.append('&gt;')
        return line

    @api.one
    @api.depends('move_line_id',
                 'move_line_id.debit',
                 'move_line_id.credit')
    def compute_scan_line(self):
        """Compute the payment slip scan line to be used
        by scanners

        :return: scan line
        :rtype: str
        """
        scan_line_list = self._compute_scan_line_list()
        self.scan_line = ''.join(scan_line_list)

    @api.one
    @api.depends('move_line_id',
                 'move_line_id.debit',
                 'move_line_id.credit')
    def compute_scan_line_div(self):
        """Compute the payment slip scan line to be used
        by scanners

        :return: scan line
        :rtype: str
        """
        company = self.env.user.company_id
        scan_line_list = self._compute_scan_line_list()
        ref_start_left = 1.5
        ref_coef_space = company.bvr_scan_line_letter_spacing or 2.55
        div = ['<div id="ocrbb">']
        for indice, block in enumerate(scan_line_list):
            div = '<div class="digitref" style="left:%smm">%s</div>'
            computed_div = div % (ref_start_left + (indice * ref_coef_space),
                                  block)
            div.append(computed_div)
        div.append('</div>')
        self.scan_line_div = ''.join(div)

    @api.model
    def get_slip_for_move_line(self, move_line):
        """Return pyment slip related to move

        :param move: `account.move.line` record
        :type move: :py:class:`openerp.models.Model`

        :return: payment slip recordset related to move line
        :rtype: :py:class:`openerp.models.Model`
        """
        return self.search(
            [('move_line_id', '=', move_line.id)]
        )

    @api.model
    def create_slip_from_move_line(self, move_line):
        """Generate `l10n_ch.payment_slip` from
        `account.move.line` recordset

        :param move_lines: Record of `account.move.line`
        :type move_line: :py:class:`openerp.models.Model`

        :return: Recordset of `l10n_ch.payment_slip`
        :rtype: :py:class:`openerp.models.Model`
        """
        return self.create({'move_line_id', move_line.id})

    @api.model
    def compute_pay_slips_from_move_lines(self, move_lines):
        """Get or generate `l10n_ch.payment_slip` from
        `account.move.line` recordset

        :param move_lines: Recordset of `account.move.line`
        :type move_lines: :py:class:`openerp.models.Model`

        :return: Recordset of `l10n_ch.payment_slip`
        :rtype: :py:class:`openerp.models.Model`

        """
        pay_slips = self.browse()
        for move in move_lines:
            if not self._can_generate(move):
                continue
            slip = self.get_slip_for_move_line(move)
            if not slip:
                slip = self.create_slip_from_move_line(move)
            if slip:
                pay_slips += slip
        return pay_slips

    @api.model
    def compute_slip_from_invoices(self, invoices):
        """Generate ```l10n_ch.payment_slip``` from
        ```account.invoice``` recordset

        :param move_lines: Recordset of `account.invoice`
        :type move_lines: :py:class:`openerp.models.Model`

        """
        for invoice in invoices:
            move_lines = invoice.get_payment_move_line()
            return self.compute_slip_from_move_lines(move_lines)

    @api.one
    def _validate(self):
        """Check if the payment slip is ready to be printed"""
        invoice = self.move_line_id.invoice
        if not invoice:
            raise exceptions.ValidationError(
                _('No invoice related to move line %') % self.move_line_id.ref
            )
        if not self._compile_check_bvr.match(
                invoice.partner_bank_id.get_account_number() or ''):
            raise exceptions.ValidationError(
                _('Your bank BVR number should be of the form 0X-XXX-X! '
                  'Please check your company '
                  'information for the invoice:\n%s') % (invoice.name)
            )
        return True
